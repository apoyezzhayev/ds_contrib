# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/core/file_structure.ipynb.

# %% ../../../nbs/core/file_structure.ipynb 3
from __future__ import annotations

import json
import os
import re

from pathlib import Path
from typing import Literal

import pandas as pd
from dotenv import load_dotenv

from ..utils import Iterifiable, listify

# %% auto 0
__all__ = ['FSNode']

# %% ../../../nbs/core/file_structure.ipynb 8
class FSNode:
    def __init__(
        self,
        name: str | None = None,
        children: dict[str, FSNode] | Literal["pattern"] | None = None,
        path: str | None = None,
        description: str | None = None,
        exists: bool | None = None,
        type: Literal["file", "group", "pattern"] | None = None,
        **kwargs,
    ):
        """File structure node class.

        Used to represent a file structure in a hierarchical way. Each node can be a file, a group of files (logical entity) or a pattern for searching files.

        Parameters
        ----------
        name : str | None, optional
            name of the node, by default None
        children : dict[str, FSNode] | Literal[&quot;pattern&quot;] | None, optional
            child nodes, by default None
        path : str | None, optional
            path of the node from the root of the file structure, by default None
        description : str | None, optional
            description of the node, by default None
        exists : bool | None, optional
            whether the node indicated in the file structure exists in a parsed files (look at `parse_files` method),
            None means that the node was not parsed yet, by default None
        type : Literal[&quot;file&quot;, &quot;group&quot;, &quot;pattern&quot;] | None, optional
            type of the node, types are: `file`, `group`, `pattern`, by default None
        """
        self.name = name
        self._children: dict[str, FSNode] | Literal["pattern"] | None = children
        self.path = path
        self.description = description
        self.exists: bool | None = exists
        self.type: Literal["file", "group", "pattern"] | None = type
        self._kwargs = kwargs

    @property
    def is_file(self):
        return self.type == "file"

    def parse_files(self, paths: Iterifiable[PathLike]) -> set[PathLike]:
        """Main method for parsing a list of files and marking the nodes that exist in the file structure.

        The method is recursive and parses all children nodes.
        WARNING: some nodes may not be parsed if they do not exist in the file structure,
        some nodes' contents may be changed e.g. for `pattern` nodes.

        Parameters
        ----------
        paths : Iterifiable[PathLike]
            iterable of paths to parse or a single path

        Returns
        -------
        set[PathLike]
            set of paths that were not parsed due to the fact that they do not exist in the file structure

        Raises
        ------
        ValueError
            If the node type is not one of `file`, `group`, `pattern`.
        """
        remained_paths = set(listify(paths, none_handlings="empty"))
        # first parse all files
        if self.type == "file":
            if self.path in remained_paths:
                self.exists = True
                remained_paths.remove(self.path)
            else:
                self.exists = False
        elif self.type == "group":
            for child in self._children.values():
                remained_paths = child.parse_files(remained_paths)
        elif self.type == "pattern":
            deleted_paths = []
            for path in remained_paths:
                if re.match(self.path, path):
                    name = Path(path).name
                    self._children[name] = self.__class__(
                        name,
                        path=path,
                        type="file",
                        description=self._kwargs["file_description"],
                        exists=True,
                    )
                    deleted_paths.append(path)
            for path in deleted_paths:
                remained_paths.remove(path)
        else:
            raise ValueError(f"Unknown node type {self.type}")
        return remained_paths

    @classmethod
    def _parse_group(cls, d: dict, parent_node: FSNode):
        parent_node.description = d.get("desc")
        parent_node.path = d.get("path")
        parent_node.type = "group"
        parent_node._children = {
            k: cls._parse_dict(v, cls(name=k)) for k, v in d["nodes"].items()
        }
        return parent_node

    @classmethod
    def _parse_pattern(cls, d: dict, parent_node: FSNode):
        parent_node.type = "pattern"
        parent_node.description = d.get("desc")
        parent_node._kwargs["file_description"] = d["path_pattern"].get("desc")
        parent_node._children = {}
        parent_node.path = d["path_pattern"]["path"]
        return parent_node

    @staticmethod
    def _parse_file_node(d: dict, parent_node: FSNode):
        parent_node.description = d.get("desc")
        parent_node.path = d.get("path")
        parent_node.type = "file"
        parent_node._children = None
        return parent_node

    def _get_files(self, files: list[FSNode] = None, only_exists: bool = False):
        if self.type == "file":
            if not only_exists or self.exists:
                files.append(self)
        elif self.type in ("group", "pattern"):
            for child in self._children.values():
                child._get_files(files, only_exists)
        else:
            raise ValueError(f"Unknown node type {self.type}")

    def get_files(self, only_exists: bool = True) -> FSNode:
        """Get all files in the file structure as a `FSNode` objects under root `FSNode` object.

        Parameters
        ----------
        only_exists : bool, optional
            whether to include only existing files, that are marked as existing in the file structure after parsing, by default True
            WARNING: this method works only after parsing files with `parse_files` method

        Returns
        -------
        FSNode
            root `FSNode` object with all files in the flat file structure as children
        """
        files = []
        self._get_files(files, only_exists)
        root_node = FSNode(
            name="files",
            description=f"All files in file structure {'excluding' if only_exists else 'including'} non existing files",
            type="group",
        )
        root_node._children = {f.name: f for f in files}
        # TODO[HIGH]: Add caching of processed files
        return root_node

    @classmethod
    def _parse_dict(cls, d: dict, parent_node: FSNode):
        if "path_pattern" in d:
            return cls._parse_pattern(d, parent_node)
        elif "nodes" in d:
            return cls._parse_group(d, parent_node)
        else:
            return cls._parse_file_node(d, parent_node)

    @classmethod
    def from_dict(cls, d: dict) -> FSNode:
        """Generate a `FSNode` with hierarchical structure from a dictionary.

        Parameters
        ----------
        d : dict
            dictionary with hierarchical structure of the file structure, e.g. as in `recslam_structure.json`

        Returns
        -------
        FSNode
            root `FSNode` object with hierarchical structure of the file structure
        """
        root_node = FSNode(name="root_node", description="root_node", type="group")
        return cls._parse_dict(d, root_node)

    def _to_dict(self):
        return {
            "path": self.path,
            "description": self.description,
            "type": self.type,
            "exists": self.exists,
        }

    def __repr__(self):
        s = f"{self.__class__.__name__}: [{self.name}]\n"
        if self._children:
            s += repr({k: v._to_dict() for k, v in self._children.items()})
        return s

    @property
    def df(self) -> pd.DataFrame:
        """Return a `pd.DataFrame` with all nodes in the file structure as rows.

        Returns
        -------
        pd.DataFrame
        """
        if self._children:
            return pd.DataFrame.from_dict(
                {k: v._to_dict() for k, v in self._children.items()}, orient="index"
            )
        else:
            return pd.DataFrame.from_dict(self._to_dict(), orient="index").T

    def _repr_html_(self):
        s = f"<b>{self.__class__.__name__}: [{self.type}]{'(empty)' if self.type != 'file' and (self._children is None or len(self._children) == 0) else ''} {self.name}</b>: {self.description}<br><br>"
        s += self.df._repr_html_()
        return s

    def __getitem__(self, key: Iterifiable[str]) -> FSNode:
        """Get a child node by name hierarchically by using a list of keys

        Parameters
        ----------
        key : Iterifiable[str]
            complex key, e.g. ["group1", "file1"], may be a single key, e.g. "group1" or even `None`, which returns the root node

        Returns
        -------
        FSNode
            node with the given key

        Raises
        ------
        KeyError
            If the node with the given key does not exist.
        KeyError
            If the node has no children.
        """
        keys = listify(key, none_handlings="empty")
        if len(keys) == 0:
            return self
        elif len(keys) == 1:
            if self._children is None:
                raise KeyError(f"Node {self.name} has no children")
            else:
                return self._children[keys[0]]
        else:
            if self._children is None:
                raise KeyError(f"Node {self.name} has no children")
            else:
                return self._children[keys[0]][keys[1:]]

    def items(self):
        return self._children.items()
